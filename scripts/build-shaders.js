const fs = require('fs');
const path = require('path');
const tsshader = require('ts-shader');

async function processSource(shaderName) {
  const vsPath = path.join('src/shaders', `${shaderName}.vs`);
  const fsPath = path.join('src/shaders', `${shaderName}.fs`);
  const outputPath = path.join('src/shaders', `${shaderName}.ts`);

  console.log(`generating ${shaderName} -> ${outputPath}`);

  const vsSource = await fs.promises.readFile(vsPath);
  const fsSource = await fs.promises.readFile(fsPath);

  const classSrc = await tsshader.generateClass({
    baseClassName: 'ShaderProgram',
    normalizeFieldNames: true,
    searchPaths: [path.dirname(vsPath)],
    inputVS: vsSource.toString(),
    inputFS: fsSource.toString()
  });

  // prepend import
  const source = `// Autogenerated file
import ShaderProgram from '../shaderprogram';
${classSrc}`;

  await fs.promises.writeFile(outputPath, source);

  return {
    name: shaderName,
    outputPath: outputPath
  }
}

const files = fs.readdirSync('src/shaders');

const shaderNames = new Set();
for (let file of files) {
  const p = path.parse(file);
  if (p.ext === '.vs' || p.ext === '.fs') {
    shaderNames.add(p.name);
  }
}

for (const shaderName of shaderNames) {
  processSource(shaderName)
    .then((e) => console.log(`wrote ${e.outputPath}`))
    .catch(e => {
      if (e instanceof tsshader.CodeGenError)
        console.error(`${e.message}: ${e.error.message}`);
      else
        throw e;
    });
}
